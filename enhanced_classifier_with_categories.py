#!/usr/bin/env python3
"""
Clasificador mejorado que incluye detecci√≥n de categor√≠as de joyer√≠a
Integra el nuevo predictor de categor√≠as con el sistema existente
"""

import cv2
import numpy as np
import os
import shutil
from pathlib import Path
import sys
import re
from datetime import datetime

# Importar el nuevo predictor de categor√≠as
try:
    from MachineLearning.jewelry_category_predictor import JewelryCategoryPredictor
    CATEGORY_PREDICTOR_AVAILABLE = True
    print("‚úÖ Predictor de categor√≠as de joyer√≠a cargado")
except ImportError as e:
    print(f"‚ö†Ô∏è Predictor de categor√≠as no disponible: {e}")
    CATEGORY_PREDICTOR_AVAILABLE = False

# Importar funciones existentes
from improved_classify_rectangles_ocr_fixed import (
    is_measurements_or_weight_only_enhanced,
    clean_output_directories
)

class EnhancedJewelryClassifier:
    """
    Clasificador mejorado que incluye categor√≠as espec√≠ficas de joyer√≠a
    """
    
    def __init__(self):
        """Inicializar el clasificador"""
        self.category_predictor = None
        
        if CATEGORY_PREDICTOR_AVAILABLE:
            try:
                self.category_predictor = JewelryCategoryPredictor()
                print("‚úÖ Clasificador de joyer√≠a con categor√≠as inicializado")
            except Exception as e:
                print(f"‚ö†Ô∏è Error inicializando predictor: {e}")
                self.category_predictor = None
        
        # Importar clasificador ML existente
        try:
            from MachineLearning.classify_image import ImageCategoryClassifier
            self.ml_classifier = ImageCategoryClassifier()
            print("‚úÖ Clasificador ML base cargado")
        except ImportError as e:
            print(f"‚ö†Ô∏è Clasificador ML base no disponible: {e}")
            self.ml_classifier = None
    
    def enhanced_rectangle_analysis_with_categories(self, image_path: str) -> dict:
        """
        An√°lisis mejorado que incluye categor√≠as de joyer√≠a
        
        Args:
            image_path: Ruta a la imagen a analizar
            
        Returns:
            dict: Resultado completo con categor√≠a si es imagen de producto
        """
        result = {
            'image_path': image_path,
            'should_discard': False,
            'discard_reason': None,
            'category': None,
            'jewelry_category': None,
            'jewelry_category_display': None,
            'jewelry_css_class': None,
            'confidence': 0.0,
            'jewelry_confidence': 0.0,
            'analysis_steps': [],
            'features': {}
        }
        
        print(f"üîç Analizando con categor√≠as: {os.path.basename(image_path)}")
        
        # Paso 1: Usar el clasificador ML existente para extraer texto
        result['analysis_steps'].append('ml_classification')
        extracted_text = ""
        
        try:
            if self.ml_classifier:
                ml_result = self.ml_classifier.classify_image(image_path)
                
                # Si el ML ya lo descarta, respetamos esa decisi√≥n
                if ml_result['final_category'] == 'blank_image':
                    result['should_discard'] = True
                    result['discard_reason'] = f"ML: {ml_result.get('description', 'Imagen en blanco')}"
                    result['confidence'] = ml_result.get('confidence', 0.9)
                    print(f"  ‚ùå ML descarta: {result['discard_reason']}")
                    return result
                
                # Extraer texto del resultado ML
                if ml_result.get('ocr_result') and ml_result['ocr_result'].get('extracted_text'):
                    extracted_text = ml_result['ocr_result']['extracted_text'].strip()
                    
        except Exception as e:
            print(f"  ‚ö†Ô∏è Error en clasificador ML: {e}")
            extracted_text = ""
        
        # Paso 2: An√°lisis de medidas/pesos (MEJORADO)
        if extracted_text:
            result['analysis_steps'].append('enhanced_measurement_analysis')
            measurement_check = is_measurements_or_weight_only_enhanced(extracted_text)
            
            if measurement_check['is_only_measurement']:
                result['should_discard'] = True
                result['discard_reason'] = f"DESCARTADO - {measurement_check['type']}: '{measurement_check['original_text']}'"
                
                # Si es una correcci√≥n OCR, indicarlo
                if 'corrected_text' in measurement_check and measurement_check['original_text'] != measurement_check['corrected_text']:
                    result['discard_reason'] += f" (correcci√≥n OCR: '{measurement_check['corrected_text']}')"
                
                result['confidence'] = 0.98
                result['measurement_details'] = measurement_check
                print(f"  ‚ùå {result['discard_reason']}")
                return result
            else:
                print(f"  ‚úÖ Texto v√°lido: '{extracted_text}' - {measurement_check['reason']}")
        
        # Paso 3: Determinar si es c√≥digo o imagen
        if extracted_text:
            # Determinar si es c√≥digo o imagen usando l√≥gica del ML
            if self.ml_classifier and hasattr(self.ml_classifier, 'classify_image'):
                try:
                    if ml_result.get('final_category') == 'product_code':
                        result['category'] = 'code'
                        print(f"  üìù Clasificado como C√ìDIGO: '{extracted_text}'")
                    else:
                        result['category'] = 'image'
                        print(f"  üñºÔ∏è Clasificado como IMAGEN con texto: '{extracted_text}'")
                except:
                    result['category'] = 'image'
            else:
                # Fallback: clasificar basado en caracter√≠sticas del texto
                result['category'] = 'code' if self._is_likely_product_code(extracted_text) else 'image'
        else:
            result['category'] = 'image'  # Sin texto = imagen
            print(f"  üñºÔ∏è Clasificado como IMAGEN (sin texto)")
        
        # Paso 4: NUEVO - Si es imagen, predecir categor√≠a de joyer√≠a
        if result['category'] == 'image' and self.category_predictor:
            result['analysis_steps'].append('jewelry_category_prediction')
            
            try:
                print(f"  üîÆ Prediciendo categor√≠a de joyer√≠a...")
                category_result = self.category_predictor.predict_jewelry_category(image_path)
                
                result['jewelry_category'] = category_result['category']
                result['jewelry_category_display'] = category_result['category_display']
                result['jewelry_css_class'] = category_result['css_class']
                result['jewelry_confidence'] = category_result['confidence']
                result['features'] = category_result.get('features', {})
                
                print(f"     üéØ Categor√≠a detectada: {category_result['category_display']}")
                print(f"     üìä Confianza: {category_result['confidence']:.3f} ({category_result['confidence_level']})")
                
            except Exception as e:
                print(f"  ‚ö†Ô∏è Error prediciendo categor√≠a: {e}")
                result['jewelry_category'] = 'sin_categoria'
                result['jewelry_category_display'] = '‚ùì Sin Categor√≠a'
                result['jewelry_css_class'] = 'category-unknown'
                result['jewelry_confidence'] = 0.0
        
        # Establecer confianza general
        if result['category'] == 'image' and result.get('jewelry_confidence'):
            # Para im√°genes, usar la confianza de la categor√≠a de joyer√≠a
            result['confidence'] = min(0.8, 0.5 + result['jewelry_confidence'] / 2)
        else:
            result['confidence'] = 0.8
        
        print(f"  ‚úÖ V√ÅLIDO - Categor√≠a: {result['category']}")
        if result.get('jewelry_category'):
            print(f"      üè∑Ô∏è Joyer√≠a: {result['jewelry_category_display']}")
        
        return result
    
    def _is_likely_product_code(self, text: str) -> bool:
        """
        Determina si un texto parece un c√≥digo de producto
        Fallback para cuando no hay ML classifier
        """
        if not text or len(text.strip()) < 4:
            return False
        
        text = text.strip()
        
        # Patrones t√≠picos de c√≥digos de producto
        # 1. Empieza con 'c' seguido de n√∫meros
        if text.lower().startswith('c') and len(text) > 5 and text[1:].isdigit():
            return True
        
        # 2. Solo n√∫meros largos
        if text.isdigit() and len(text) >= 6:
            return True
        
        # 3. Patr√≥n alfanum√©rico t√≠pico
        digits = sum(c.isdigit() for c in text)
        letters = sum(c.isalpha() for c in text)
        
        if len(text) >= 6 and digits >= 3 and letters >= 1:
            return True
        
        return False

def process_rectangles_with_categories(input_dir, codes_dir, images_dir, discards_dir):
    """
    Versi√≥n mejorada que incluye categor√≠as de joyer√≠a para im√°genes
    
    Args:
        input_dir: Directorio con las im√°genes de rect√°ngulos
        codes_dir: Directorio donde se guardar√°n los rect√°ngulos de texto
        images_dir: Directorio donde se guardar√°n los rect√°ngulos de im√°genes
        discards_dir: Directorio donde se guardar√°n los rect√°ngulos descartados
    """
    # Limpiar las carpetas de salida
    clean_output_directories(codes_dir, images_dir, discards_dir)
    
    # Crear clasificador mejorado
    classifier = EnhancedJewelryClassifier()
    
    # Obtener todas las im√°genes
    image_extensions = ['.jpg', '.jpeg', '.png', '.bmp', '.tiff']
    image_paths = []
    
    for ext in image_extensions:
        image_paths.extend(list(Path(input_dir).glob(f'*{ext}')))
        image_paths.extend(list(Path(input_dir).glob(f'*{ext.upper()}')))
    
    if not image_paths:
        print(f"No se encontraron im√°genes en {input_dir}")
        return
    
    # Ordenar por n√∫mero de rect√°ngulo
    def extract_rect_number(path):
        match = re.search(r'rect_(\d+)', path.name)
        return int(match.group(1)) if match else float('inf')
    
    image_paths = sorted(image_paths, key=extract_rect_number)
    
    print(f"üîç PROCESAMIENTO CON CATEGOR√çAS - {len(image_paths)} rect√°ngulos")
    print("   üéØ Detecta categor√≠as: Anillos, Colgantes, Pulseras, Pendientes")
    print("=" * 70)
    
    # Contadores
    text_count = 0
    image_count = 0
    discard_count = 0
    category_stats = {}
    
    # Procesar cada imagen
    for i, image_path in enumerate(image_paths, 1):
        file_name = os.path.basename(str(image_path))
        print(f"\nüìä [{i}/{len(image_paths)}] {file_name}")
        
        # An√°lisis mejorado con categor√≠as
        analysis = classifier.enhanced_rectangle_analysis_with_categories(str(image_path))
        
        if analysis['should_discard']:
            # Guardar en descartes
            discard_count += 1
            discard_destination = os.path.join(discards_dir, file_name)
            shutil.copy2(image_path, discard_destination)
            
            # Crear archivo de informaci√≥n del descarte
            info_filename = f"{os.path.splitext(file_name)[0]}_discard_info.json"
            info_path = os.path.join(discards_dir, info_filename)
            
            discard_info = {
                'filename': file_name,
                'reason': analysis['discard_reason'],
                'confidence': analysis['confidence'],
                'timestamp': datetime.now().isoformat(),
                'analysis_steps': analysis['analysis_steps']
            }
            
            import json
            with open(info_path, 'w', encoding='utf-8') as f:
                json.dump(discard_info, f, indent=2, ensure_ascii=False)
            
            print(f"  üóëÔ∏è DESCARTADO: {analysis['discard_reason']}")
            
        elif analysis['category'] == 'code':
            # Guardar como c√≥digo
            code_destination = os.path.join(codes_dir, file_name)
            shutil.copy2(image_path, code_destination)
            text_count += 1
            print(f"  üìù ‚Üí C√ìDIGO guardado")
            
        elif analysis['category'] == 'image':
            # Guardar como imagen CON informaci√≥n de categor√≠a
            image_destination = os.path.join(images_dir, file_name)
            shutil.copy2(image_path, image_destination)
            image_count += 1
            
            # Crear archivo JSON con informaci√≥n de categor√≠a
            category_info_filename = f"{os.path.splitext(file_name)[0]}_category.json"
            category_info_path = os.path.join(images_dir, category_info_filename)
            
            category_info = {
                'filename': file_name,
                'category': analysis.get('jewelry_category', 'sin_categoria'),
                'category_display': analysis.get('jewelry_category_display', '‚ùì Sin Categor√≠a'),
                'css_class': analysis.get('jewelry_css_class', 'category-unknown'),
                'confidence': analysis.get('jewelry_confidence', 0.0),
                'confidence_level': 'alta' if analysis.get('jewelry_confidence', 0) >= 0.8 else 'media' if analysis.get('jewelry_confidence', 0) >= 0.6 else 'baja',
                'features': analysis.get('features', {}),
                'timestamp': datetime.now().isoformat()
            }
            
            # Guardar informaci√≥n de categor√≠a
            import json
            with open(category_info_path, 'w', encoding='utf-8') as f:
                json.dump(category_info, f, indent=2, ensure_ascii=False)
            
            # Actualizar estad√≠sticas
            category = analysis.get('jewelry_category', 'sin_categoria')
            category_stats[category] = category_stats.get(category, 0) + 1
            
            print(f"  üñºÔ∏è ‚Üí IMAGEN guardada")
            if analysis.get('jewelry_category'):
                print(f"      üè∑Ô∏è Categor√≠a: {analysis['jewelry_category_display']}")
    
    # Mostrar resumen
    print("\n" + "=" * 70)
    print("üìä RESUMEN CON CATEGOR√çAS DE JOYER√çA")
    print("=" * 70)
    print(f"  üìù C√≥digos:    {text_count}")
    print(f"  üñºÔ∏è Im√°genes:   {image_count}")
    print(f"  üóëÔ∏è Descartes:  {discard_count}")
    print(f"  üì¶ Total:      {len(image_paths)}")
    
    if category_stats:
        print(f"\nüè∑Ô∏è CATEGOR√çAS DE JOYER√çA DETECTADAS:")
        category_display = {
            'anillos': 'üíç Anillos',
            'colgantes y collares': 'üîó Colgantes y Collares',
            'pulseras': '‚åö Pulseras', 
            'pendientes': 'üëÇ Pendientes',
            'sin_categoria': '‚ùì Sin Categor√≠a'
        }
        
        for category, count in sorted(category_stats.items(), key=lambda x: x[1], reverse=True):
            display_name = category_display.get(category, category)
            percentage = (count / image_count * 100) if image_count > 0 else 0
            print(f"  ‚Ä¢ {display_name}: {count} im√°genes ({percentage:.1f}%)")
    
    # Verificar balance
    if text_count == image_count:
        print(f"\n‚úÖ BALANCE PERFECTO: {text_count} c√≥digos ‚Üî {image_count} im√°genes")
    else:
        diff = abs(text_count - image_count)
        print(f"\n‚öñÔ∏è BALANCE: {text_count} c√≥digos vs {image_count} im√°genes (diferencia: {diff})")
    
    print(f"\nüìÅ Archivos guardados en:")
    print(f"  üìù C√≥digos: {codes_dir}")
    print(f"  üñºÔ∏è Im√°genes: {images_dir} (con archivos JSON de categor√≠as)")
    print(f"  üóëÔ∏è Descartes: {discards_dir}")
    
    print(f"\nüéØ FUNCIONALIDADES NUEVAS:")
    print(f"  ‚úÖ Categorizaci√≥n autom√°tica de im√°genes de joyer√≠a")
    print(f"  ‚úÖ Archivos JSON con informaci√≥n detallada de categor√≠as")
    print(f"  ‚úÖ Estad√≠sticas por tipo de joyer√≠a")
    print(f"  ‚úÖ Preparado para mostrar tarjetas en la interfaz web")

if __name__ == "__main__":
    # Valores predeterminados
    input_dir = "/home/slendy/PythonProjects/ImagesManagement/rectangles_output"
    codes_dir = "/home/slendy/PythonProjects/ImagesManagement/codes_output"
    images_dir = "/home/slendy/PythonProjects/ImagesManagement/images_output"
    discards_dir = "/home/slendy/PythonProjects/ImagesManagement/discards_output"
    
    print("üöÄ PROCESADOR CON CATEGOR√çAS DE JOYER√çA")
    print("   ‚úÖ Clasifica autom√°ticamente: Anillos, Colgantes, Pulseras, Pendientes")
    print("   ‚úÖ Genera archivos JSON con informaci√≥n detallada")
    print("   ‚úÖ Compatible con interfaz web mejorada")
    print("=" * 70)
    
    # Ejecutar procesamiento
    process_rectangles_with_categories(input_dir, codes_dir, images_dir, discards_dir)
